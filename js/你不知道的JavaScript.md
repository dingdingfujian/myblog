# 你不知道的JavaScript


## 作用域和闭包

### 作用域是什么

#### 编译

- 一般的编译过程：分词/词法分析->解析/语法分析(AST)->代码生成

- JavaScript的编译过程大部分发生在执行的前几微秒，而不是发生在构建之前

#### 

- 作用域

	- 引擎：负责编译和执行

	- 编译器：负责语法解析及代码生成等

	-  作用域：负责收集并维护由所有声明的标识符，确定当前代码对这些标识符的访问权

	- LHS：赋值

	- RHS：查找

### 词法作用域

#### 词法作用域是在写代码或者说定义时确定的，而动态作用域是在运行时确定的(this也是)。词法作用域关注函数在何处声明，动态作用域关注函数在何处调用。

- function foo() {   
  console.log( a ); // 2  
  }  
  function bar() {   
  var a = 3;  
  foo();   
  }  
  var a = 2;       
  bar();

#### JS中的作用域就是词法作用域

#### 作用域链是基于调用栈的

#### 词法作用域基于代码中的作用域嵌套

### 函数作用域和块作用域

####  函数作用域

- 在任意代码片段外添加包装函数可以内部的变量和函数定义‘隐藏’起来

	- 缺点：1.函数名本身会污染所在作用域。2.必须显式地通过函数名调用才能运行内部的代码

	-  解决办法：匿名立即执行函数

		- 缺点：1.匿名函数在栈追踪中不会显示出有意义的函数名，使得调试变得困难。2.当函数需要引用自身时只能通过过期的arguments.callee引用。3.可读性下降

		- 解决办法：行内函数表达式，给函数表达式指定一个名称

		- (function(){…})() = (function(){…}()

#### 块作用域

- 1.with。2.try/catch，catch分句会创建一个块作用域。3.let。4.const

### 提升

#### JS代码先编译后执行。只有声明本身会被提升，而赋值或其他逻辑运算会被留在原地。eg：var a = 2;分为两个阶段：var a和a = 2,第一部分会在编译阶段被提升，而第二部分不会。PS:函数声明亦会被提升，但函数表达式不会

#### 函数声明提升优先于变量声明。p40

### 作用域闭包

#### 无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行都会使用闭包。

#### 在定时器，事件监听器，Ajax请求，跨窗口通信，Web Workers或其他任何异步(同步)任务中，只要使用了回调函数，实际上就是在使用闭包

#### for循环头部的let声明有一个特殊的行为，这个行为指出变量在循环过程中不止被声明一次，每次迭代都会声明。随后的每次迭代都会使用上次迭代结束时的值来初始化这个变量

#### 模块的两个主要特征：1.为创建一个内部作用域而调用一个包装函数(每次调用都会创建一个新的模块 实例)；2.包装函数的返回值至少包含一个对内部函数的引用，这样就会创建涵盖整个包装函数内部作用域的闭包

- 当只需一个模块实例时可以通过 IIFE 实现单例模式

- 基于函数的模块并不是一个能被稳定识别的模式(编译器无法识别)，它们 的 API 语义只有在运行时才会被考虑进来。因此可以在运行时修改一个模块 的 API

- ES6 模块 API 更加稳定(API 不会在运行时改变)

## 

### this和对象原型

#### this

- 

	- this的绑定和函数声明的位置没有关系，只取决于函数的调用方式

	- 不能使用this来引用一个词法作用域内部的东西

	- this的绑定规则

		- 1.默认绑定

			- 严格模式下，全局对象无法使用默认绑定，因此this会被绑定到undefined

				- 对于默认绑定来说,决定 this 绑定对象的并不是调用位置是否处于严格模式,而是 函数体是否处于严格模式。如果函数体处于严格模式,this 会被绑定到 undefined,否则 this 会被绑定到全局对象

		- 2.隐式绑定

			- 对象属性引用链中只有顶层或者说最后一层会影响调用位置

				- function foo() {   
				  console.log( this.a );  
				  }  
				  var obj2 = {   
				  a: 42,  
				  foo: foo  
				   };  
				  var obj1 = {   
				  a: 2,  
				  obj2: obj2   
				  };  
				  obj1.obj2.foo(); // 42

		- 3.显式绑定

			- 1.call/apply

			- 2.bind

		- 4.new绑定

			- 实际上并不存在所谓的“构造函数”,只有对于函数的“构造调用”

	- 优先级：new>显式>隐式>默认

	- 如果把 null 或者 undefined 作为 this 的绑定对象传入 call、apply 或者bind,这些值在调用时会被忽略,实际应用的是默认绑定规则

		- 缺点：如果某个函数确实使用了this，那么默认绑定规则把this绑定到全局对象会产生不可预测的后果

		- 解决办法：使用Object.create(null)创建一个空对象代替null等。PS：Object.create(null)创建的对象不会创建Object.prototype这个委托，所以它比’{}’更空

	- 箭头函数不使用 this 的四种标准规则,而是根据外层(函数或者全局)作用域来决定this，箭头函数的绑定无法被修改

#### 对象

- 类型

	- 不同的对象在底层都表示为二进制,在 JavaScript 中二进制前三位都为 0 的话会被判 断为 object 类型,null 的二进制表示是全 0,自然前三位也是 0,所以执行 typeof 时会返回“object”

	- null 和 undefined 没有对应的构造形式,它们只有文字形式。相反,Date 只有构造,没有文字形式

	- 在必要时语言会自动把字符串字面量转换成一个 String 对象,也就是说你并不需要 显式创建一个对象。JavaScript 社区中的大多数人都认为能使用文字形式时就不要使用构 造形式

	- Number和String使用文字形式创建时为字面量，使用构造形式创建时为对象； Object、Array、Function 和 RegExp(正则表达式)来说,无论使用文字形式还是构 造形式,它们都是对象,不是字面量

- 内容

	-  . 操作符要求属性名满足标识符的命名规范,而 [".."] 语法 可以接受任意 UTF-8/Unicode 字符串作为属性名；此外,由于 [".."] 语法使用字符串来访问属性,所以可以在程序中构造这个字符串

	- ES6 增加了可计算属性名,可以在文字形式中使用 [] 包裹一个表达式来当作属性名

	- 属性描述符

		- value

		- writable

		- configurable

			- 把 configurable 修改成 false 是单向操作,无法撤销；不管是不是处于严格模式,尝 试修改一个不可配置的属性描述符都会出错；  
			  注意有一个小小的例外:即便属性是 configurable:false,我们还是可以 把 writable 的状态由 true 改为 false,但是无法由 false 改为 true。另外不影响value的修改。

		- enumerable

		- 方法：Object.defineProperty()

	- 不变性

		- 对象常量：结合 writable:false 和 configurable:false 就可以创建一个真正的常量属性(不可修改、 重定义或者删除)

		- 禁止扩展：使用 Object.prevent Extensions(..)可以禁止一个对象添加新的属性并且保留已有属性

		- 密封：Object.seal(..) 会创建个“密封”的对象,这个方法实际上会在一个现有对象上调用Object.preventExtensions(..) 并把所有现有属性标记为configurable:false

		- 冻结：Object.freeze(..) 会创建一个冻结对象,这个方法实际上会在一个现有对象上调用 Object.seal(..) 并把所有“数据访问”属性标记为 writable:false,这样就无法修改它们 的值

	- Getter和Setter

		- 当给一个属性定义 getter、setter 或者两者都有时,这个属性会被定义为“访问描述 符”(和“数据描述符”相对)。

		- 通常来说 getter 和 setter 是成对出现的(只定义一个的话 通常会产生意料之外的行为)

	- 存在性

		- in 操作符可以检查容器内是否有某个值,但是它实际上检查的是某 个属性名是否存在。对于数组来说这个区别非常重要,4 in [2, 4, 6]的结 果并不是你期待的 True,因为 [2, 4, 6] 这个数组中包含的属性名是 0、1、 2,没有 4

		- 在数组上应用 for..in 循环有时会产生出人意料的结果,因为这种枚举不 仅会包含所有数值索引,还会包含所有可枚举属性。最好只在对象上应用 for..in 循环,如果要遍历数组就使用传统的 for 循环来遍历数值索引。

- 遍历

	- forEach

	- every

	- some

	- for..in

		- 使用 for..in 遍历对象是无法直接获取属性值的,因为它实际上遍历的是对象中的所有可枚举属性,你需要手动获取属性值。

	- for..of

#### 混合对象‘类’

- 类意味着复制

- 传统的类被实例化时,它的行为会被复制到实例中。类被继承时,行为也会被复制到子类中

- 多态(在继承链的不同层次名称相同但是功能不同的函数)看起来似乎是从子类引用父 类,但是本质上引用的其实是复制的结果

- JavaScript 并不会(像类那样)自动创建对象的副本

- 总地来说,在 JavaScript 中模拟类是得不偿失的,虽然能解决当前的问题,但是可能会埋 下更多的隐患

#### 行为委托

- 行为委托认为对象之间是兄弟关系,互相委托,而不是父类和子类的关系

- JavaScript 的 [[Prototype]] 机制本质上就是行为委托机制。也就是说,我们可以选择在 JavaScript 中努 力实现类机制(参见第 4 和第 5 章),也可以拥抱更自然的 [[Prototype]] 委托机制

- 对象关联(对象之间互相关联)是一种编码风格,它倡导的是直接创建和关联对象,不把它们抽象成类。对象关联可以用基于 [[Prototype]] 的行为委托非常自然地实现。

