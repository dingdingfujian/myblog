# 服务器端推送
1. polling（轮询）
2. long polling（长轮询）
3. 永久帧(iframe)
4. SSE（Server-sent Event）
5. WebSocket
6. HTTP 2

> 轮询需要客户端定时不断地发送请求到服务器端去查询有没有数据，有便取回数据，没有就关闭，因此需要服务器有很高的处理速度和资源；
> 长轮询则是客户端发送一个请求到服务器，如果有数据便取回数据或者超时后关闭连接，然后再次发送一个请求，重复以上过程；没有就继续保持这个链接直到服务器响应，因此需要服务器具有很高的并发处理能力。
>
> 
> 以上两者每次发送请求都会携带完整的Header，导致信息交换效率低，浪费带宽；请求与响应需要一一对应。 
> 
> SSE（Server-sent Event）只能单向的由服务器向客户端推送。

> keep-alive在一次 TCP 连接中完成多个 HTTP 请求。
> 
> keep-alive和long-polling是两回事，Connection: Close和Connection: Keep-Alive都可以支持long-polling，差别只在于开销不同
> KeepAlive是相对于TCP来说的，就是多个HTTP请求使用同一条TCP通道，省掉三步握手。而long polling是对于HTTP来说的。浏览器发起一个HTTP请求后，服务器不返回，而是一直挂着，当有消息的时候返回。浏览器这里一直等着这个请求，一返回马上可以处理数据。超时只是一个补充手段，因为不可能让这个HTTP请求一直挂着


> 相对于轮询，WebSocket 的优势不说自明，但是相对于长轮询，其优势又在哪里呢？
> 参见[WebSocket 是什么原理？为什么可以实现持久连接？](https://www.zhihu.com/question/20215561)简短的讲就是：通常客户端（A）发送的 HTTP请求是要经过nginx服务器（接线员B）处理然后再传给相应的处理程序（客服C）的。B 的处理速度非常快，因此A 与 B 之间的连接非常廉价。但是 C 的处理能力就比较慢了。而 WebSocket 只需要维持 A 与 B 之间的连接即可，一旦C 有消息就通知 B 而不用一直被 A 的连接占用。长轮询则需要维持 A 与 C 的连接，一旦并发量变大，C 的资源就容易耗尽。
