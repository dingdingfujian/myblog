
模块对象和 IIFE（模块模式）
通过使用模块对象和立即运行的函数表达式（IIFE），我们可以减少全局命名空间污染。在本方法中，我们只暴露了一个对象给全局作用域，该对象包含了应用程序中所需的所有方法和值。
但是，这依然不算是完美的解决方案。这种方案依然会遇到上节相同的问题：

缺乏依赖解析：文件的顺序依然重要，myApp.js 必须出现在所有其它文件之前，main.js 必须处在所有其它库文件之后。
全局命令空间污染：现在全局变量的数量变成了 1，但是还不是 0 。

CommonJS 并非一个 JavaScript 库，而是一个标准化组织，像 ECMA 或者 W3C 一样。ECMA 定义了 JavaScript 语言规范。W3C 定义了 JavaScript Web API，比如 DOM 和 DOM 事件。CommonJS 的目标是为 Web 服务器、桌面和命令行应用程序定义一套通用的 API。
CommonJS 还定义了模块 API 。因为在服务器应用程序中没有 HTML 页面，也没有 script 标记，所以就得有一些清晰的模块 API。模块需要暴露（export）给其它模块使用，并且是可访问的（import）。

CommonJS 和 AMD 解决了模块模式剩下的两个问题：依赖解析和全局作用域污染，现在我们只需要注意每个模块或者文件的依赖，并且不再有全局作用域污染。

RequireJS 和 AMD 解决了我们以前所遇到的所有问题。但是，它有带来了其它一些不怎么严重的问题：

AMD 语法很古怪。因为所有东西都封装在 define 函数内，代码就有一些额外的缩进。对于小文件来说，这不是啥问题，但是对于大的代码库来说，就可能是精神上的疲惫。
数组中的依赖列表必须与函数的参数列表匹配。如果有很多依赖，就很难维护依赖的次序。如果模块中有几十个依赖，后来又要从中间删除一个，那么就很难找到匹配的模块和参数。
在当前浏览器下（HTTP 1.1），加载很多小文件会降低性能。

AMD和CommonJS是运行时加载，只有在代码执行时才能确认需要的东西，所以只能整体加载一个模块，虽然也许只是用到该模块的某一个方法。
ES6的模块则是编译时加载。在编译阶段（这里说的编译应该是指构建工具中的编译，而非JS引擎中的编译）就能确定模块的依赖关系，所以可以做到局部加载。这里的局部加载并不是由import来完成，其实import什么也没做。ES6将模块加载过程的细节完全交由最终的实现（比如webpack）来定义，模块执行的其它部分倒是在规范中有详细定义。
CommonJS输出的是值得拷贝，ES6模块输出的是值的引用。
CommonJS中exports 和 module.exports 的区别：

module.exports 初始值为一个空对象 {}
exports 是指向的 module.exports 的引用
require() 返回的是 module.exports 而不是 exports